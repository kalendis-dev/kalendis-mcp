"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToLocalTime = void 0;
const dayjs_1 = __importDefault(require("dayjs"));
// We'll need to import tz and utc from dayjs if they aren't automatically extended
require("dayjs/plugin/utc");
require("dayjs/plugin/timezone");
require("dayjs/plugin/customParseFormat"); // May be needed for some string parsing
dayjs_1.default.extend(require('dayjs/plugin/utc'));
dayjs_1.default.extend(require('dayjs/plugin/timezone'));
dayjs_1.default.extend(require('dayjs/plugin/customParseFormat'));
/**
 * Converts availability times to the user's local timezone while preserving the "sticky" time behavior.
 *
 * This function ensures that times are correctly displayed in the user's local timezone context:
 * - If a time was originally saved as 9:00 AM in America/New_York, it should always display as 9:00 AM
 *   for users in that timezone regardless of DST changes.
 * - If a user in a different timezone (e.g., America/Chicago) sees that same time slot as 8:00 AM,
 *   it should always display as 8:00 AM regardless of DST changes.
 *
 * @param dataToConvert - Array of users with availability data or an array of availability items.
 * @returns The same data with times adjusted for the user's local timezone.
 */
const convertToLocalTime = (dataToConvert) => {
    // Deep clone to avoid mutating the original array
    const clonedData = JSON.parse(JSON.stringify(dataToConvert));
    const currentUserTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const adjustTimes = (availability) => {
        return availability.map((item) => {
            let start = item.start ?? item.startTime;
            let end = item.end ?? item.endTime;
            const originalItemOffset = typeof item.originalItemOffset === 'number' ? item.originalItemOffset : item.offset;
            const originalItemTimeZone = item.timeZone;
            if (originalItemTimeZone && typeof originalItemOffset === 'number' && start && end) {
                try {
                    const startUtc = dayjs_1.default.utc(start);
                    const endUtc = dayjs_1.default.utc(end);
                    const originalLocalDtStart = startUtc.add(originalItemOffset, 'minutes');
                    const originalLocalDtEnd = endUtc.add(originalItemOffset, 'minutes');
                    const s_year = originalLocalDtStart.year();
                    const s_month = originalLocalDtStart.month();
                    const s_date = originalLocalDtStart.date();
                    const s_hour = originalLocalDtStart.hour();
                    const s_minute = originalLocalDtStart.minute();
                    const e_year = originalLocalDtEnd.year();
                    const e_month = originalLocalDtEnd.month();
                    const e_date = originalLocalDtEnd.date();
                    const e_hour = originalLocalDtEnd.hour();
                    const e_minute = originalLocalDtEnd.minute();
                    const localStartString = `${s_year}-${String(s_month + 1).padStart(2, '0')}-${String(s_date).padStart(2, '0')}T${String(s_hour).padStart(2, '0')}:${String(s_minute).padStart(2, '0')}:00`;
                    const localEndString = `${e_year}-${String(e_month + 1).padStart(2, '0')}-${String(e_date).padStart(2, '0')}T${String(e_hour).padStart(2, '0')}:${String(e_minute).padStart(2, '0')}:00`;
                    const startInOriginalZone = dayjs_1.default.tz(localStartString, originalItemTimeZone);
                    const endInOriginalZone = dayjs_1.default.tz(localEndString, originalItemTimeZone);
                    const newStart = startInOriginalZone.tz(currentUserTimeZone).format();
                    const newEnd = endInOriginalZone.tz(currentUserTimeZone).format();
                    if (item.start) {
                        item.start = newStart;
                    }
                    else {
                        item.startTime = newStart;
                    }
                    if (item.end) {
                        item.end = newEnd;
                    }
                    else {
                        item.endTime = newEnd;
                    }
                }
                catch (error) {
                    console.error('Error converting time:', error, 'Input item:', JSON.stringify(item));
                    // Keep original times if conversion fails
                }
            }
            if (item.segments && Array.isArray(item.segments)) {
                item.segments = adjustTimes(item.segments);
            }
            // Return the modified item (or original if no times to adjust)
            return item;
        });
    };
    if (Array.isArray(clonedData) && clonedData.length > 0 && clonedData[0].availability) {
        return clonedData.map(user => ({
            ...user,
            availability: user.availability ? adjustTimes(user.availability) : [],
        }));
    }
    else {
        return adjustTimes(clonedData);
    }
};
exports.convertToLocalTime = convertToLocalTime;
